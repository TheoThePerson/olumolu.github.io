use gtk::prelude::*;
use gtk::{Application, ApplicationWindow, Box, Button, Entry, Label, Notebook, Orientation, SpinButton, Terminal};
use gtk::{gio, glib};
use std::collections::HashMap;
use std::fs;
use std::path::Path;
use ssh2::{BlockDirections, Channel, Config, Session};

struct SSHConfig {
    host: String,
    username: String,
    password: String,
    port: u16,
    key: Option<String>,
}

struct SSHApp {
    window: ApplicationWindow,
    notebook: Notebook,
    config_page: Box,
    host_entry: Entry,
    username_entry: Entry,
    password_entry: Entry,
    port_spinbutton: SpinButton,
    key_entry: Entry,
    connect_button: Button,
    terminal_page: Box,
    terminal: Terminal,
    configs: Vec<SSHConfig>,
    connections: HashMap<String, Terminal>,
}

impl SSHApp {
    fn new() -> Self {
        let window = ApplicationWindow::new();
        window.set_title("SSH App");
        window.set_default_size(800, 600);

        let notebook = Notebook::new();
        window.set_child(&notebook);

        let config_page = Box::new(Orientation::Vertical, 10);
        config_page.set_margin_top(10);
        config_page.set_margin_bottom(10);
        config_page.set_margin_start(10);
        config_page.set_margin_end(10);

        let host_entry = Entry::new();
        host_entry.set_placeholder_text("Host");
        config_page.append(&host_entry);

        let username_entry = Entry::new();
        username_entry.set_placeholder_text("Username");
        config_page.append(&username_entry);

        let password_entry = Entry::new();
        password_entry.set_placeholder_text("Password");
        password_entry.set_visibility(false);
        config_page.append(&password_entry);

        let port_spinbutton = SpinButton::new_with_range(1.0, 65535.0, 1.0);
        port_spinbutton.set_value(22.0);
        config_page.append(&port_spinbutton);

        let key_entry = Entry::new();
        key_entry.set_placeholder_text("SSH Key");
        config_page.append(&key_entry);

        let connect_button = Button::new_with_label("Connect");
        connect_button.connect_clicked(move |button| {
            let host = host_entry.text();
            let username = username_entry.text();
            let password = password_entry.text();
            let port = port_spinbutton.value_as_int() as u16;
            let key = key_entry.text();

            let config = SSHConfig {
                host: host.clone(),
                username: username.clone(),
                password: password.clone(),
                port,
                key: if key.is_empty() { None } else { Some(key.clone()) },
            };

            let mut terminal = Terminal::new();
            terminal.feed_child(&format!("ssh {}@{} -p {}\n", username, host, port));
            terminal.feed_child(&format!("{}\n", password));

            let connection_name = format!("{}@{}", username, host);
            notebook.append_page(&terminal, &Label::new(Some(&connection_name)));
            notebook.set_tab_reorderable(&terminal, true);

            Self::add_connection(&mut self.connections, connection_name, terminal);
        });
        config_page.append(&connect_button);

        notebook.append_page(&config_page, &Label::new(Some("Config")));

        let terminal_page = Box::new(Orientation::Vertical, 10);
        terminal_page.set_margin_top(10);
        terminal_page.set_margin_bottom(10);
        terminal_page.set_margin_start(10);
        terminal_page.set_margin_end(10);

        let terminal = Terminal::new();
        terminal_page.append(&terminal);

        notebook.append_page(&terminal_page, &Label::new(Some("Terminal")));

        window.show();

        SSHApp {
            window,
            notebook,
            config_page,
            host_entry,
            username_entry,
            password_entry,
            port_spinbutton,
            key_entry,
            connect_button,
            terminal_page,
            terminal,
            configs: Vec::new(),
            connections: HashMap::new(),
        }
    }

    fn add_connection(connections: &mut HashMap<String, Terminal>, name: String, terminal: Terminal) {
        connections.insert(name, terminal);
    }

    fn disconnect(&mut self, name: &str) {
        if let Some(terminal) = self.connections.remove(name) {
            self.notebook.remove_page(&terminal);
        }
    }

    fn save_configs(&self, path: &Path) {
        let mut file = fs::File::create(path).unwrap();
        for config in &self.configs {
            writeln!(file, "{}:{}@{}:{}{}", config.username, config.password, config.host, config.port, config.key.as_ref().unwrap_or(&"".to_string())).unwrap();
        }
    }

    fn load_configs(&mut self, path: &Path) {
        let file = fs::File::open(path).unwrap();
        for line in file.lines() {
            let line = line.unwrap();
            let mut parts = line.split(':');
            let username = parts.next().unwrap();
            let password = parts.next().unwrap();
            let host = parts.next().unwrap();
            let port = parts.next().unwrap().parse::<u16>().unwrap();
            let key = parts.next().unwrap();
            let config = SSHConfig {
                host: host.to_string(),
                username: username.to_string(),
                password: password.to_string(),
                port,
                key: if key.is_empty() { None } else { Some(key.to_string()) },
            };
            self.configs.push(config);
        }
    }

    fn edit_config(&mut self, index: usize) {
        let config = &mut self.configs[index];
        let dialog = gtk::Dialog::new(Some("Edit Config"), Some(&self.window), gtk::DialogFlags::MODAL);
        let content_area = dialog.content_area();
        let grid = gtk::Grid::new();
        grid.set_column_homogeneous(true);
        grid.set_row_homogeneous(true);
        content_area.add(&grid);

        let host_label = gtk::Label::new(Some("Host"));
        grid.attach(&host_label, 0, 0, 1, 1);
        let host_entry = gtk::Entry::new();
        host_entry.set_text(&config.host);
        grid.attach(&host_entry, 1, 0, 1, 1);

        let username_label = gtk::Label::new(Some("Username"));
        grid.attach(&username_label, 0, 1, 1, 1);
        let username_entry = gtk::Entry::new();
        username_entry.set_text(&config.username);
        grid.attach(&username_entry, 1, 1, 1, 1);

        let password_label = gtk::Label::new(Some("Password"));
        grid.attach(&password_label, 0, 2, 1, 1);
        let password_entry = gtk::Entry::new();
        password_entry.set_text(&config.password);
        password_entry.set_visibility(false);
        grid.attach(&password_entry, 1, 2, 1, 1);

        let port_label = gtk::Label::new(Some("Port"));
        grid.attach(&port_label, 0, 3, 1, 1);
        let port_spinbutton = gtk::SpinButton::new_with_range(1.0, 65535.0, 1.0);
        port_spinbutton.set_value(config.port as f64);
        grid.attach(&port_spinbutton, 1, 3, 1, 1);

        let key_label = gtk::Label::new(Some("SSH Key"));
        grid.attach(&key_label, 0, 4, 1, 1);
        let key_entry = gtk::Entry::new();
        key_entry.set_text(config.key.as_ref().unwrap_or(&"".to_string()));
        grid.attach(&key_entry, 1, 4, 1, 1);

        let save_button = gtk::Button::new_with_label("Save");
        save_button.connect_clicked(move |_| {
            config.host = host_entry.text().to_string();
            config.username = username_entry.text().to_string();
            config.password = password_entry.text().to_string();
            config.port = port_spinbutton.value_as_int() as u16;
            config.key = if key_entry.text().is_empty() { None } else { Some(key_entry.text().to_string()) };
            dialog.close();
        });
        dialog.add_button(save_button, gtk::ResponseType::Accept);

        let cancel_button = gtk::Button::new_with_label("Cancel");
        cancel_button.connect_clicked(move |_| {
            dialog.close();
        });
        dialog.add_button(cancel_button, gtk::ResponseType::Reject);

        dialog.run();
    }

    fn delete_config(&mut self, index: usize) {
        self.configs.remove(index);
    }

    fn reorder_connections(&mut self, name: &str, position: i32) {
        let mut connections = self.connections.clone();
        self.connections.clear();
        for (i, (k, v)) in connections.into_iter().enumerate() {
            if i == position as usize {
                self.connections.insert(name.to_string(), v);
            } else {
                self.connections.insert(k, v);
            }
        }
    }

    fn rename_connection(&mut self, old_name: &str, new_name: &str) {
        if let Some(terminal) = self.connections.remove(old_name) {
            self.connections.insert(new_name.to_string(), terminal);
        }
    }

    fn connect_ftp(&mut self, host: &str, username: &str, password: &str, port: u16) {
        let mut ftp = ftp::Ftp::new(host, port);
        ftp.login(username, password).unwrap();
        let mut terminal = Terminal::new();
        terminal.feed_child(&format!("ftp {}:{}@{}\n", username, password, host));
        let connection_name = format!("{}@{}", username, host);
        self.notebook.append_page(&terminal, &Label::new(Some(&connection_name)));
        self.notebook.set_tab_reorderable(&terminal, true);
        Self::add_connection(&mut self.connections, connection_name, terminal);
    }

    fn connect_sftp(&mut self, host: &str, username: &str, password: &str, port: u16) {
        let mut sftp = sftp::Sftp::new(host, port);
        sftp.login(username, password).unwrap();
        let mut terminal = Terminal::new();
        terminal.feed_child(&format!("sftp {}:{}@{}\n", username, password, host));
        let connection_name = format!("{}@{}", username, host);
        self.notebook.append_page(&terminal, &Label::new(Some(&connection_name)));
        self.notebook.set_tab_reorderable(&terminal, true);
        Self::add_connection(&mut self.connections, connection_name, terminal);
    }
}

fn main() {
    gio::prelude::init();
    let application = Application::new(Some("com.example.sshapp"), Default::default())
        .expect("failed to create application");
    application.connect_activate(build_ui);
    application.run_default();
}

fn build_ui(application: &gtk::Application) {
    let ssh_app = SSHApp::new();
    application.add_window(&ssh_app.window);
}



    More advanced error handling for FTP and SFTP connections
    Support for other types of connections (e.g. Telnet, RDP)
    A way to import and export SSH configurations
    A way to set default SSH configurations
